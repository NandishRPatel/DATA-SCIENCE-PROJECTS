rm(list=ls())
A <- matrix(rpois(64,5), 8, 8)
A
C
C = A %*% t(A)
C
A
C
matrix(matrix(rpois(64,5), 8, 8))
A
A
set.seed(73)
rm(list=ls())
A <- matrix(rpois(64,5), 8, 8)
A
set.seed(73)
A1 <- matrix(matrix(rpois(64,5), 8, 8))
A1
set.seed(73)
A1 <- matrix(rpois(64,5), 8, 8)
A1
set.seed(73)
A <- matrix(rpois(64,5), 8, 8)
A
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of the matrix C
eig_C <- eigen(C)
# Getting eigenvalues from eig_C
eval_C <- eig_C$values
# Getting eigenvectors from eig_C
evec_C <- eig_C$vectors
# Printing eigenvalues and eigenvectors
print("Eigenvalues of C : \n")
print(eval_C)
print("Eigenvectos of C : \n")
print(evec_C)
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of the matrix C
eig_C <- eigen(C)
# Getting eigenvalues from eig_C
eval_C <- eig_C$values
# Getting eigenvectors from eig_C
evec_C <- eig_C$vectors
# Printing eigenvalues and eigenvectors
print("Eigenvalues of C : \n")
print(eval_C)
print("Eigenvectos of C : \n")
print(evec_C)
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of the matrix C
eig_C <- eigen(C)
# Getting eigenvalues from eig_C
eval_C <- eig_C$values
# Getting eigenvectors from eig_C
evec_C <- eig_C$vectors
# Printing eigenvalues and eigenvectors
cat("Eigenvalues of C : \n")
print(eval_C)
cat("Eigenvectos of C : \n")
print(evec_C)
C
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Let's check if matrix S is symmetric or not
cat("Is Matrix S symmetric? : ", all(C == t(C)), "\n")
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Let's calculate the eigenvalues of S
eval <- eigen(C)$values
# Printing the eigenvalues of S
cat("Eigenvalues of C : ", eval, "\n")
# Checking if all eigenvalues are positive or not
cat("Are all eigenvalues of C positive? : ", all(eval > 0), "\n")
(2 - 5.666667)
(3 - 5.166667)
(6 - 5.666667)
(8 - 5.166667)
(5 - 5.666667)
(2 - 5.166667)
(9 - 5.666667)
(4 - 5.166667)
(11 - 5.666667)
(10 - 5.166667)
(1 - 5.666667)
(4 - 5.166667)
(-3.666667)(-2.166667)
(-3.666667)*(-2.166667)
(0.333333)*(2.833333)
(-0.666667)*(-3.166667)
(3.333333)*(-1.166667)
(5.333333)*(4.833333)
(-4.666667)*(-1.166667)
7.944446 + 0.9444434 + 2.111112 + -3.88889 + 25.77777 + 5.444446
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigenvectors from eig_C
U <- eigen(C)$vectors
# Creating an Identity matrix
I <- diag(nrow = 8)
# Checking if t(U) %*% U is equal to identity matrix
t(U) %*% U == I
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigenvectors from eig_C
U <- eigen(C)$vectors
# Creating an Identity matrix
I <- diag(nrow = 8)
# Checking if t(U) %*% U is equal to identity matrix
round(t(U) %*% U) == I
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigenvectors from eig_C
U <- eigen(C)$vectors
# Creating an Identity matrix
I <- diag(nrow = 8)
# Checking if t(U) %*% U is equal to identity matrix
all(round(t(U) %*% U) == I)
U
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigenvectors from eig_C
U <- eigen(C)$vectors
# Creating an Identity matrix
I <- diag(nrow = 8)
# Checking if t(U) %*% U is equal to identity matrix
cat("Is t(U) %*% U equal to I? : ", all(round(t(U) %*% U) == I))
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of C
eig_C = eigen(C)
# Getting eigenvectors from eig_C
U <- eig_C$vectors
# Creating a diagonal matrix with eigenvalues
lambda = diag(eig_C$values)
C == U %*% lambda %*% t(U)
U %*% lambda %*% t(U)
C
all.equal(C, U %*% lambda %*% t(U))
all(C, U %*% lambda %*% t(U))
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of C
eig_C = eigen(C)
# Getting eigenvectors from eig_C
U <- eig_C$vectors
# Creating a diagonal matrix with eigenvalues
lambda = diag(eig_C$values)
all.equal(C, U %*% lambda %*% t(U))
# Setting the seed for reproducibility
set.seed(73)
# Cleaning the environment
rm(list=ls())
# Creating 8 x 8 matrix A from Poission distribution with lambda parameter 5
A <- matrix(rpois(64,5), 8, 8)
# Creating matrix C
C = A %*% t(A)
# Getting eigen properties of C
eig_C = eigen(C)
# Getting eigenvectors from eig_C
U <- eig_C$vectors
# Creating a diagonal matrix with eigenvalues
lambda = diag(eig_C$values)
# Verifying the SVD of C
cat("Verified SVD for C? : ", all.equal(C, U %*% lambda %*% t(U)))
M <- matrix(c(-3.666667, -2.1666667, 7, 0.333333, 2.833333, 1,
-0.666667, -3.166667, -1, 3.333333, -1.166667, -5,
5.333333, 4.833333, -6, -4.666667, -1.166667, 4),
nrow = 6, ncol = 3, byrow = T)
M
SSCP <- t(M) %*% M
SSCP
# Assume that we have already calculated the matrix M
M <- matrix(c(-3.666667, -2.1666667, 7, 0.333333, 2.833333, 1, -0.666667, -3.166667, -1, 3.333333, -1.166667, -5, 5.333333, 4.833333, -6, -4.666667, -1.166667, 4), nrow = 6, ncol = 3,
byrow = T)
# SSCP as mentioned in the assignment
SSCP <- t(M) %*% M
# Printing the SSCP
cat("SSCP matrix is : \n")
SSCP
# Assume that we have already calculated the matrix M
S <- matrix(c(-15.066667, -7.666667, -18.4, -7.666667, -9.766667, -7.4,
-18.4, -7.4, -25.6), nrow = 3, ncol = 3, byrow = T)
diagonal <- diag(S)
diagonal
D <- matrix(rep(0, 9), ncol = 3, nrow = 3)
D
diag(D) <- diagonal
D
diagonal <- (diag(S)) ^ (-1/2)
diagonal
diagonal <- 1/sqrt(diag(S))
diagonal
diagonal <- inv(sqrt(diag(S)))
diagonal <- solve(sqrt(diag(S)))
diagonal
diagonal <- diag(S)
diagonal
2^2
diagonal <- sqrt(diag(S))
diagonal
diagonal <- sqrt(diag(S), 2)
diagonal <- sqrt(diag(S), 1)
c()
?c()
diagonal <- diag(S) ^ (0.5)
# Assume that we have already calculated the matrix M
S <- matrix(c(15.066667, 7.666667, -18.4, 7.666667, 9.766667, -7.4,
-18.4, -7.4, 25.6), nrow = 3, ncol = 3, byrow = T)
diagonal <- diag(S) ^ (0.5)
diagonal
# Assume that we have already calculated the matrix M
S <- matrix(c(15.066667, 7.666667, -18.4, 7.666667, 9.766667, -7.4,
-18.4, -7.4, 25.6), nrow = 3, ncol = 3, byrow = T)
diagonal <- 1/(diag(S) ^ (0.5))
diagonal
D <- matrix(rep(0, 9), ncol = 3, nrow = 3)
D
diag(D) <- diagonal
D
D %*% S %*% D
# Assume that we have already calculated the matrix M
S <- matrix(c(15.066667, 7.666667, -18.4, 7.666667, 9.766667, -7.4,
-18.4, -7.4, 25.6), nrow = 3, ncol = 3, byrow = T)
# Getting diagonal and taking inverse of root
diagonal <- 1/(diag(S) ^ (0.5))
# Creating a matrix D
D <- matrix(rep(0, 9), ncol = 3, nrow = 3)
# Setting the diagonal of D
diag(D) <- diagonal
# Printing the result
D %*% S %*% D
# Getting diagonal and taking inverse of root
diagonal <- 1/(diag(S) ^ (0.5))
# Creating a matrix D
D <- matrix(rep(0, 9), ncol = 3, nrow = 3)
# Setting the diagonal of D
diag(D) <- diagonal
diagonal <- 1/(diag(S) ^ (0.5))
D <- matrix(rep(0, 9), ncol = 3, nrow = 3)
diag(D) <- diagonal
?factanal
# Reading the data
## Training data - Covariates
X_train_SMOTE = read.csv("./DATA/X_train_SMOTE.csv")
## Training data - Response Variable
y_train_SMOTE = read.csv("./DATA/y_train_SMOTE.csv", header = F)
setwd("D:/DATA-SCIENCE-PROJECTS/BANK MARKETING DATA")
X_train_SMOTE = read.csv("./DATA/X_train_SMOTE.csv")
## Training data - Response Variable
y_train_SMOTE = read.csv("./DATA/y_train_SMOTE.csv", header = F)
# Need to convert the dummy variables into one categorical variable
## Job
job_cols <- as.matrix(X_train_SMOTE[7:17])
job_cat <- factor(job_cols %*% 1:ncol(job_cols),
labels = c("job_admin", colnames(job_cols)))
## Marital status
marital_cols <- as.matrix(X_train_SMOTE[18:19])
marital_cat <- factor(marital_cols %*% 1:ncol(marital_cols),
labels = c("marital_divorced", colnames(marital_cols)))
## Education
education_cols <- as.matrix(X_train_SMOTE[20:22])
education_cat <- factor(education_cols %*% 1:ncol(education_cols),
labels = c("education_primary", colnames(education_cols)))
## Month
month_cols <- as.matrix(X_train_SMOTE[23:33])
month_cat <- factor(month_cols %*% 1:ncol(month_cols),
labels = c("month_apr", colnames(month_cols)))
## Poutcome
poutcome_cols <- as.matrix(X_train_SMOTE[34:36])
poutcome_cat <- factor(poutcome_cols %*% 1:ncol(poutcome_cols),
labels = c("poutcome_failure", colnames(poutcome_cols)))
## Contact
contact_cols <- as.matrix(X_train_SMOTE[37:38])
contact_cat <- factor(contact_cols %*% 1:ncol(contact_cols),
labels = c("contact_cellular", colnames(contact_cols)))
# Creating a new dataframe
new_data <- X_train_SMOTE[1:6]
# Adding the newly created categorical variables to the dataframe
new_data["job"] <- factor(gsub("job_", "", job_cat))
new_data["marital"] <- factor(gsub("marital_", "", marital_cat))
new_data["education"] <- factor(gsub("education_", "", education_cat))
new_data["month"] <- factor(gsub("month_", "", month_cat))
new_data["poutcome"] <- factor(gsub("poutcome_", "", poutcome_cat))
new_data["contact"] <- factor(gsub("contact_", "", contact_cat))
# Adding response variable to the dataframe
new_data["subscribed"] <- y_train_SMOTE
## Since outcome variable is dichotomous we will use binomial response
##  distributition with GLM.
glm_1 = glm(subscribed ~ ., family = binomial(), data = new_data)
summary(glm_1)
car::Anova(glm_1)
View(contact_cols)
car::avPlots(glm_1, terms = ~ balance + day)
car::avPlots(glm_1, terms = ~ balance)
plot(glm_1)
glm_2 = glm(subscribed ~ . + I(balance ^ 2) + I(day ^ 2), family = binomial(), data = new_data)
summary(glm_2)
car::Anova(glm_2)
## Since outcome variable is dichotomous we will use binomial response
##  distributition with GLM.
glm_1 = glm(subscribed ~ ., family = binomial(link = log), data = new_data)
summary(glm_1)
## Since outcome variable is dichotomous we will use binomial response
##  distributition with GLM.
glm_1 = glm(subscribed ~ ., family = binomial(link = "log"), data = new_data)
## Since outcome variable is dichotomous we will use binomial response
##  distributition with GLM.
glm_1 = glm(subscribed ~ ., family = binomial(), data = new_data)
summary(glm_1)
library(GGally)
ggpairs(new_data)
smooth.spline(subscribed ~ day, data = new_data)
?smooth.spline
smooth.spline(new_data.subscribed ~ new_data.day)
smooth.spline(new_data$subscribed ~ new_data$day)
plot(smooth.spline(new_data$subscribed ~ new_data$day))
plot(smooth.spline(y = new_data$subscribed, x = new_data$day))
plot(new_data$subscribed, new_data$day)
plot(new_data$subscribed ~ new_data$day)
lines(smooth.spline(x = new_data$day, y = new_data$subscribed))
plot(new_data$subscribed ~ new_data$day)
lines(smooth.spline(x = new_data$day, y = new_data$subscribed), df = 5)
plot(new_data$subscribed ~ new_data$day)
lines(smooth.spline(x = new_data$day, y = new_data$subscribed, df = 5))
lines(smooth.spline(x = new_data$day, y = new_data$subscribed, df = 10))
lines(smooth.spline(x = new_data$day, y = new_data$subscribed, df = 60000))
lines(smooth.spline(x = new_data$day, y = new_data$subscribed, df = 23000))
plot(new_data$subscribed ~ new_data$day)
lines(smooth.spline(x = new_data$day, y = new_data$subscribed, df  = 1000))
AIC(glm_1, glm_2)
X_valid = read.csv("./DATA/X_valid.csv")
y_valid = read.csv("./DATA/y_valid.csv", header = F)
## Job
job_cols <- as.matrix(X_valid[7:17])
job_cat <- factor(job_cols %*% 1:ncol(job_cols),
labels = c("job_admin", colnames(job_cols)))
## Marital status
marital_cols <- as.matrix(X_valid[18:19])
marital_cat <- factor(marital_cols %*% 1:ncol(marital_cols),
labels = c("marital_divorced", colnames(marital_cols)))
## Education
education_cols <- as.matrix(X_valid[20:22])
education_cat <- factor(education_cols %*% 1:ncol(education_cols),
labels = c("education_primary", colnames(education_cols)))
## Month
month_cols <- as.matrix(X_valid[23:33])
month_cat <- factor(month_cols %*% 1:ncol(month_cols),
labels = c("month_apr", colnames(month_cols)))
## Poutcome
poutcome_cols <- as.matrix(X_valid[34:36])
poutcome_cat <- factor(poutcome_cols %*% 1:ncol(poutcome_cols),
labels = c("poutcome_failure", colnames(poutcome_cols)))
## Contact
contact_cols <- as.matrix(X_valid[37:38])
contact_cat <- factor(contact_cols %*% 1:ncol(contact_cols),
labels = c("contact_cellular", colnames(contact_cols)))
# Creating a new dataframe
new_data_valid <- X_valid[1:6]
# Adding the newly created categorical variables to the dataframe
new_data_valid["job"] <- factor(gsub("job_", "", job_cat))
new_data_valid["marital"] <- factor(gsub("marital_", "", marital_cat))
new_data_valid["education"] <- factor(gsub("education_", "", education_cat))
new_data_valid["month"] <- factor(gsub("month_", "", month_cat))
new_data_valid["poutcome"] <- factor(gsub("poutcome_", "", poutcome_cat))
new_data_valid["contact"] <- factor(gsub("contact_", "", contact_cat))
# Adding response variable to the dataframe
new_data_valid["subscribed"] <- y_valid
head(new_data_valid)
new_data_valid[1:12]
glm_2.predict(new_data_valid[1:12])
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:12])
head(glm_2_pred)
predict.glm(glm_2, newdata = new_data_valid.iloc[1:10,1:12])
new_data_valid.iloc[1:10,1:12]
predict.glm(glm_2, newdata = new_data_valid[1:10, 1:12])
?predict.glm()
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:10, 1:12], type = "R")
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:10, 1:12], type = "r")
head(glm_2_pred)
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:10, 1:12], type = "t")
head(glm_2_pred)
temp_pred = ifelse(glm_2_pred > 0.5, 1, 0)
head(temp_pred)
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:10, 1:12], type = "r")
temp_pred = ifelse(glm_2_pred > 0.5, 1, 0)
head(temp_pred)
head(y_valid)
library.install("caret")
library.installs("caret")
installed.packages("caret")
library(caret)
installed.package("caret")
install.packages("caret")
install.packages("caret")
caret::confusionMatrix()
?caret::confusionMatrix()
caret::confusionMatrix(data = temp_pred, reference = y_valid)
install.packages("generics")
install.packages("generics")
library(generics)
caret::confusionMatrix(data = temp_pred, reference = y_valid)
table(temp_pred, y_valid)
glm_2_pred = predict.glm(glm_2, newdata = new_data_valid[1:12], type = "r")
temp_pred = ifelse(glm_2_pred > 0.5, 1, 0)
head(temp_pred)
head(y_valid)
table(temp_pred, y_valid)
head(t(y_valid))
t(y_valid)
y_valid[1]
y_valid[:]
y_valid[]
head(t(temp_pred))
t(temp_pred)
class(temp_pred)
class(y_valid)
View(y_valid)
class(y_valid["V1"])
table(temp_pred, y_valid$V1)
3425/3423+154
3425/(3423+154)
335/(607+335)
temp_pred = ifelse(glm_2_pred > 0.6, 1, 0)
head(t(temp_pred))
head(t(y_valid))
table(temp_pred, y_valid$V1)
temp_pred = ifelse(glm_2_pred > 0.5, 1, 0)
table(temp_pred, y_valid$V1)
temp_pred = ifelse(glm_2_pred > 0.3, 1, 0)
table(temp_pred, y_valid$V1)
remove.packages(generics)
remove.packages("generics")
library(caret)
install.packages("generics")
install.packages("generics")
library(caret)
glm_2 = glm(subscribed ~ . + I(balance ^ 2), family = binomial(), data = new_data)
car::Anova(glm_2)
glm_2 = glm(subscribed ~ . + I(balance ^ 2) + ~day, family = binomial(), data = new_data)
glm_2 = glm(subscribed ~ . + I(balance ^ 2) + !day, family = binomial(), data = new_data)
AIC(glm_1, glm_2)
summary(glm_2)
car::Anova(glm_2)
